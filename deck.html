<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DataVec Actor-based Narrative</title>
  <style>
    body {
      background-color: #1e1e1e;
      color: #ccffcc;
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 3rem;
    }
    .slide {
      max-width: 1200px;
      margin: auto;
    }
    .slide_section {
      font-size: 1.5rem;
      font-weight: bold;
      color: #66ffcc;      
      margin-bottom: 3rem;
      padding: 2rem;
      border: 2px solid #66ffcc;
      border-radius: 8px;
      background-color: #2e2e2e;
    }
    .title {
      font-size: 3rem;
      font-weight: bold;
      margin-bottom: 1rem;
    }
    .tagline {
      font-size: 1.5rem;
      color: #66ffcc;
      margin-bottom: 1rem;
    }
    .content {
      font-size: 1.1rem;
      color: #d0d0d0;
      margin-top: 1rem;
    }
    .diagram {
      background: #2e2e2e;
      color: #ffffff;
      border-left: 5px solid #66ffcc;
      padding: 1rem;
      margin-top: 1rem;
      white-space: pre-wrap;
      font-family: monospace;
    }
    a {
      color: #66ffcc;
      text-decoration: none;
    }
    .nav {
      /* float to the top center */
      position: fixed;
      top: 1rem;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      /* padding */

      display: flex;
      gap: 1rem;
      /* border */
      /*
      border: 2px solid #66ffcc;
      border-radius: 8px;
      background-color: #2e2e2e;
      padding: 1rem;
      */
      /* box shadow */
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      /* transition */
      transition: background-color 0.3s ease;

    }
  </style>
</head>
<body>

  <div class="nav" style="text-align: center; margin-top: 2rem;">
    <button onclick="changeSlide(-1)" style="background: #66ffcc; color: #1e1e1e; padding: 0.75rem 1.5rem; border: none; cursor: pointer; font-weight: bold;">&larr; Back</button>
    <button onclick="goHome()" style="background: #66ffcc; color: #1e1e1e; padding: 0.75rem 1.5rem; border: none; cursor: pointer; font-weight: bold;">Home</button>
    <button onclick="changeSlide(1)" style="background: #66ffcc; color: #1e1e1e; padding: 0.75rem 1.5rem; border: none; cursor: pointer; font-weight: bold;">Next &rarr;</button>
  </div>

<div class="slide">
  <div class="slide_section">12-Factor versus Actor</div>
  <div class="title">The Twelve-Factor Trap: Modularity via Scattering</div>
  <div class="tagline">Occam's Scale: "Do not scatter without necessity."</div>
  <div class="content">
    <p>
      Twelve-Factor apps transformed modularity and scalability—at the hidden cost of scattering logic, state, and observability into externalized pipelines.
    </p>
    <p><strong>Why does scaling inevitably spiral into complexity?</strong></p>
    <p><strong>Are we scattering essential context without necessity?</strong></p>
    <p>Functional paradigms like MapReduce taught us to decompose computation—but at scale, this becomes a spatial problem too. Scattering work across services, then gathering results through glue, mirrors map-reduce in physical form. What began as logic partitioning becomes infrastructure overhead.</p>

    <div class="diagram">
      Clean Modularity (Twelve-Factor Apps)
          │
          ▼
      Hidden Overhead:
        ├─ Env var loading
        ├─ Log aggregation
        ├─ Service meshes
        ├─ State serialization
        └─ Constant coordination
    </div>
  </div>
</div>

<div class="slide">
    <div class="slide_section">12-Factor versus Actor</div>
    <div class="title">How Actors Became 12-Factor</div>
    <div class="content">
      <p>
        Actors were originally designed to <strong>avoid scattering</strong>: logic, state, and messaging naturally co-located for simplicity and performance.
      </p>
      <p>
        Yet modern implementations—AWS Lambda, Cloudflare Durable Objects, Temporal workflows, Akka clusters—externalize actor state, effectively making them just another type of 12-factor component.
      </p>
  
      <div class="diagram">
        Modern "12-Factor Actor":
          [Stateless Actor]
            ├─ External DB/Cache
            ├─ External Queue/Event Bus
            └─ External Observability (Logs/Metrics)
      </div>
  
      <p>
        <strong>If actors become stateless and externalized, are they still actors—or just more scattering?</strong>
      </p>
    </div>
  </div>
  
  <div class="slide">
    <div class="slide_section">12-Factor versus Actor</div>
    <div class="title">The Actor Model Was Always Anti-12-Factor</div>
    <div class="content">
      <p>
        The original actor paradigm emphasized <strong>structural locality</strong>—state, logic, and observability integrated naturally within each actor.
      </p>
      <p>
        True actors encapsulate state internally, communicate via messages, and maintain intrinsic observability. No external scattering, no unnecessary overhead.
      </p>
  
      <div class="diagram">
        True Actor Model:
          [Actor]
            ├─ Logic (Behavior)
            ├─ State (Local Persistence)
            └─ Observability (Intrinsic)
      </div>
  
      <p>
        <strong>Actors were never meant to externalize state—actors were always about structural locality.</strong>
      </p>
    </div>
  </div>

  <div class="slide">
    <div class="slide_section">12-Factor versus Actor</div>
    <div class="title">DataVec: Actors Done Right ("Statelessful")</div>
    <div class="tagline">"Statelessful": Map Less, Reduce More.</div>
    <div class="content">
      <p>
        DataVec embraces the true actor paradigm, creating actors as <strong>ontological objects</strong>: a single, coherent memory space that integrates logic, state, and observability intrinsically.
      </p>
  
      <div class="diagram">
        Ontological Actor (DataVec):
          ├─ Logic (Composable behaviors)
          ├─ State (Local, Structured)
          └─ Observability (Embedded, Deterministic)
      </div>
  
      <p>
        "Statelessful" means isolating state appropriately, sharing context efficiently, and minimizing redundant external mappings.
      </p>
  
      <p>
        <strong>No scattering. No externalization. No unnecessary overhead.</strong>
      </p>
    </div>
  </div>

  <div class="slide">
    <div class="slide_section">12-Factor versus Actor</div>
    <div class="title">The Platform for WinterTC and Beyond</div>
    <div class="content">
      <p>
        DataVec’s actor runtime (<code>mnvkd</code>) is not just efficient—it’s foundational. It enables structured, composable platforms like <a href="https://wintertc.org">WinterTC</a> (cloud function specification) to be built atop <strong>true actors</strong> rather than 12-factor scaffolding.
      </p>
      <p>
        Each actor is a memory-scoped process with deterministic behavior and embedded observability. Services like Redis, SQLite, and even custom vector databases can be implemented as actors with native in-memory messaging.
      </p>
  
      <div class="diagram">
        WinterTC-Compatible Platform:
          ├─ Built from local, structured actors
          ├─ Zero glue, zero serialization
          ├─ Composable over HTTP/2 or native APIs
          └─ Efficient introspection without scraping
      </div>
  
      <p>
        <strong>The cloud solved scale by scattering.<br>
        DataVec solves structure by restoring locality.</strong>
      </p>
    </div>
  </div>

  <div class="slide">
    <div class="slide_section">Philosophy</div>
    <div class="title">In Praise of Idleness</div>
    <div class="content">
      <blockquote style="margin: 1.5rem 0; font-style: italic;">
        “There are two kinds of work: first, altering the position of matter at or near the earth’s surface;  
        second, telling other people to do so.”<br>
        <cite>—Bertrand Russell, <em>In Praise of Idleness</em> (1932)</cite>
      </blockquote>
      <p>
        Modern cloud infrastructure is dominated by the second kind—not computation, but coordination. Orchestration. Messaging. Retrying. Logging. Managing.
      </p>
      <p>
        But the goal of a system isn’t to move—it’s to rest. Pipelines exist to bring data to its optimal resting point—not to keep it in motion forever.
      </p>
      <p>
        <strong>DataVec is built to minimize movement by maximizing structure.</strong><br>
        No layers of delegation. No glue-filled pipelines. Just actors, in memory, doing the work directly.
      </p>
      <p>
        <em>In Praise of Idleness</em> isn’t about doing nothing—it’s about designing systems that no longer have to work so hard.
      </p>
      <p>
        And the market is starting to catch on.
      </p>
    </div>
  </div>
      
  <div class="slide">
    <div class="slide_section">The Market</div>
    <div class="title">The Market Is Moving Toward Us</div>
    <div class="content">
      <p>
        Edge and serverless platforms are trending toward structured, local-first computing—but they’re building on the wrong foundation.
      </p>
      <p>
        Cloudflare, AWS, Vercel, and others are converging on <strong>WinterTC-style runtimes</strong> that resemble the browser: localized APIs, scoped execution, lightweight isolation.
      </p>
      <p>
        But they still treat actors like 12-factor components:
      </p>
      <div class="diagram">
        Durable Objects → External Storage<br>
        AWS Step Functions → Orchestration Glue<br>
        Temporal → Workflow-as-a-Service<br>
        <br>
        All still externalize logic, state, or both.
      </div>
      <p>
        <strong>They’ve seen the need—but not the root cause. DataVec gives them the structural answer.</strong>
      </p>
    </div>
  </div>

  <div class="slide">
    <div class="slide_section">The Market</div>
    <div class="title">Strategic Insight: Small Data Wins</div>
    <div class="content">
      <p>
        While the industry raced to externalize everything into the cloud, Apple quietly took the opposite path—and won.
      </p>
  
      <ul>
        <li><strong>iOS services run on local, structured state</strong>—often just SQLite files.</li>
        <li><strong>iCloud acts as a syncing fabric, not a database</strong>—state lives <em>on the device</em>.</li>
        <li>Their model is <strong>small-data per user</strong>, not centralized big data.</li>
      </ul>
  
      <p>
        Apple didn’t reject scale—they localized it. In doing so, they achieved speed, reliability, and simplicity. 
        <strong>But that locality also brought something deeper: privacy by design. Local, structured state is easier to secure, encrypt, and reason about—because it stays where it belongs.</strong>
      </p>
  
      <div class="diagram">
        Cloud Model: External State → Coordination → Observability<br>
        Apple Model: Local State → Sync → Native Observability
      </div>
  
      <p>
        <strong>This isn't behind—it’s ahead. Big data is actually made of small-data problems. And locality wins.</strong>
      </p>
      <p><strong>Local-first design isn’t a constraint—it’s how you build private, performant, and predictable systems at scale.</strong></p>
    </div>
  </div>
    
  <div class="slide">
    <div class="slide_section">The Market</div>
    <div class="title">Why Now: The Economic Turn</div>
    <div class="content">
      <p>
        The era of infinite funding and infrastructure sprawl is over. Efficiency is no longer optional—it’s strategic.
      </p>
  
      <ul>
        <li><strong>Budgets are tighter.</strong> Runway matters more than revenue multiples.</li>
        <li><strong>Teams are leaner.</strong> Infrastructure must be simpler to reason about and maintain.</li>
        <li><strong>Efficiency, composability, and insight</strong> are now value drivers—not afterthoughts.</li>
      </ul>
  
      <p>
        Most stacks were built to chase growth. Few were built to last.
      </p>
  
      <div class="diagram">
        Old Model: Scale → Glue → Complexity → Overspend<br>
        New Model: Structure → Locality → Clarity → Efficiency
      </div>
  
      <p>
        <strong>DataVec was designed for this moment:</strong><br>
        A structural foundation that replaces layers, not just builds more.<br>
        Local-first, introspectable, radically efficient.
      </p>
    </div>
  </div>

  <div class="slide">
    <div class="slide_section">The Market</div>
    <div class="title">The Opportunity</div>
    <div class="content">
      <p>
        Infrastructure today is bloated with coordination layers—glue code, observability tooling, orchestration logic, and state bridges.
      </p>
  
      <ul>
        <li><strong>$70B+</strong> projected for serverless and edge compute by 2032</li>
        <li><strong>$20B+</strong> spent annually on observability, tracing, and logging tools</li>
        <li>Billions more spent on integration middleware—queues, proxies, orchestrators, brokers</li>
      </ul>
  
      <p>
        These costs are symptoms. They reflect what the stack is missing:
      </p>
  
      <ul>
        <li>No structural memory model—so state is externalized</li>
        <li>No shared locality—so coordination becomes I/O-bound</li>
        <li>No introspection—so debugging becomes telemetry engineering</li>
      </ul>
  
      <p>
        <strong>Most solutions today retrofit structure on top of scattering. They solve symptoms, not causes.</strong>
      </p>
      <p>
        DataVec starts where those stop: local structure, embedded observability, and composable actors by default.
      </p>

      <div class="diagram">
        The Cost of Missing Structure:
          ├─ Performance loss
          ├─ Developer burnout
          ├─ Vendor lock-in
          └─ Infinite glue
      </div>
  
      <p>
        <strong>The real opportunity isn’t faster glue—it’s no glue at all. That’s what DataVec delivers.</strong>
      </p>
    </div>
  </div>

  <div class="slide">
    <div class="slide_section">The Solution</div>
    <div class="title">What We're Building</div>
    <div class="content">
      <p>
        <strong>DataVec is for servers what SQLite is for databases.</strong><br>
        A vertically integrated execution model—not a framework, not a function runner.
      </p>
  
      <p>
        At its core is <code>mnvkd</code>, a memory-anchored C runtime that:
      </p>
  
      <ul>
        <li>Implements an M:N:1 scheduler with stackless coroutines and isolated micro-heaps</li>
        <li>Uses actor-based microprocesses for fault isolation—no threads, no kernel processes</li>
        <li>Runs services like <code>inetd</code>—but faster, safer, scoped per connection</li>
        <li>Embeds observability—no external glue, no log scraping, no orchestration spaghetti</li>
        <li>No more reduce-map cycles to rehydrate scattered state—each actor is self-contained and always live. Structural locality replaces coordination as the primitive.</li>
      </ul>
  
      <div class="diagram">
        Full-Stack Integration:
          ├─ Threading Framework (coroutine + I/O aggregation)
          ├─ Actor Kernel (soft real-time, memory-safe)
          ├─ Service Framework (protocol-native, multiplexed)
          └─ Application Framework (WinterTC-ready)
      </div>
  
      <p>
        <strong>This isn’t another server stack. It’s the layer beneath them all—and it’s already running.</strong>
      </p>
    </div>
  </div>

  <div class="slide">
    <div class="slide_section">The Solution</div>
    <div class="title">We Built This Because We Had To</div>
    <div class="content">
      <p><strong>1. High-Scale, Low-Latency Demands (OpenRTB):</strong><br>
      As an ad-tech technical co-founder, I built a real-time bidder that processed 12 billion JSON requests per day—peaking at 1M QPS—on commodity VMs. We had no cookie-based filtering, so every bid was stateful. One exchange even asked how we outperformed their custom Java HFT stack on bare metal. The answer? Structural locality and zero glue.</p>
  
      <p><strong>2. Cloud Cost Burnout (Postmortem):</strong><br>
      Later, I joined a startup that had gone bankrupt from cloud costs—millions lost to Lambda, RDS, and orchestration overhead. They didn’t need microservices; they needed structure. That’s when I realized the real problem: modern infra forces you to rent complexity, not run software.</p>
  
      <p><strong>And one deeper frustration:</strong><br>
      Why is it so hard to write a custom protocol handler like <code>inetd</code>—and have it scale? Abstractions don’t have to add overhead. I built DataVec so developers can write high-performance services from day one—without switching languages or rewriting everything just to go from prototype to production.</p>
    </div>
  </div>  

  <div class="slide">
    <div class="slide_section">The Solution</div>
    <div class="title">The Team</div>
    <div class="content">
      <p>
        We're systems thinkers, platform engineers, and runtime architects.
      </p>
  
      <ul>
        <li>Built for low-level efficiency and high-level developer ergonomics</li>
        <li>Decades of experience in C, runtime internals, and distributed infrastructure</li>
        <li>Deep intuition for composability, observability, and system safety</li>
      </ul>
  
      <p>
        This is not a pivot. It’s the system we were always building toward.<br>
        From the memory model to the protocol layer—we own the whole stack.
      </p>
  
      <div class="diagram">
        Core Values:
          ├─ Structure-first
          ├─ Efficiency by design
          ├─ Developer-oriented
          └─ Composable by principle
      </div>
  
      <p>
        <strong>This isn’t just a runtime—it’s our operating philosophy.</strong>
      </p>
    </div>
  </div>

  <div class="slide">
    <div class="slide_section">The Solution</div>
    <div class="title">The Roadmap</div>
    <div class="content">
      <ul>
        <li><strong>Prototype Complete:</strong> <code>mnvkd</code> running at 300k QPS/core in internal benchmarks</li>
        <li><strong>Self-Hosted Launch:</strong> Native TLS, Fetch API, and WinterTC runtime parity</li>
        <li><strong>Managed Service Launch:</strong> NextJS and WinterTC integration with optional AI-assisted JS→C translation</li>
        <li><strong>Service Protocol Library:</strong> Actor-based microservices for drop-in replacements:
          <ul>
            <li><strong>Redis:</strong> Text-keyed Judy array with RESP protocol</li>
            <li><strong>SQLite:</strong> Embedded per-connection micro-thread</li>
            <li><strong>Vector DB:</strong> Per-tenant memory-optimized spatial layout</li>
          </ul>
        </li>
      </ul>
  
      <div class="diagram">
        Platform Timeline:
          ├─ Core runtime → ✓
          ├─ Edge-ready interface → In Progress
          ├─ Microservice protocol kit → Next
          └─ DevX and SDK layers → Funding Enabled
      </div>
  
      <p>
        <strong>This is the base layer for a new ecosystem—composable, local-first, and production-ready.</strong>
      </p>
    </div>
  </div>

  <div class="slide">
    <div class="slide_section">The Solution</div>
    <div class="title">Let's Build It Right</div>
    <div class="content">
      <p>
        The cloud solved scale.<br>
        <strong>DataVec solves structure.</strong>
      </p>
  
      <p>
        We’re raising a <strong>$1.5M pre-seed round</strong> to bring DataVec to early adopters and complete the core platform.
      </p>
  
      <ul>
        <li>Finalize developer SDKs, CLI tools, and safe interop layers</li>
        <li>Embed observability and introspection into the actor runtime</li>
        <li>Integrate with edge-native AI, local-first SaaS, and structured pipelines</li>
        <li>Grow the team: systems engineer, developer advocate, and design contributor</li>
      </ul>
  
      <div class="diagram">
        Funding Use:
          ├─ Product polish & DX
          ├─ Ecosystem integration
          ├─ Community-building
          └─ Strategic hires
      </div>
  
      <p>
        <strong>If you're betting on edge-native platforms, structural simplicity, and local-first design—we're your runtime.</strong>
      </p>
    </div>
  </div>

  <div class="slide">
    <div class="slide_section">The Pitch</div>
    <div class="title">Efficient Enough to Sell as a Service</div>
    <div class="content">
      <p>
        Most platforms build abstraction layers that eat margin: cold starts, orchestration, logging glue, state rehydration.
      </p>
      <p>
        <strong>DataVec runs so efficiently that we can host structured compute as a service—and still make a profit.</strong>
      </p>
      <div class="diagram">
        Traditional Serverless = Cost Sink:
          ├─ Cold start latency
          ├─ Overhead from orchestration
          ├─ External storage IOPS
          └─ Runtime tax (GC, threads, logs)
        
        DataVec = Structured Margin:
          ├─ 104 KB per actor (measured)
          ├─ mmap() persistence, zero-copy
          ├─ No scatter/reduce overhead
          └─ Built-in observability
      </div>
    </div>
  </div>
  
  <div class="slide">
    <div class="slide_section">The Pitch</div>
    <div class="title">Compute That Pays for Itself</div>
    <div class="content">
      <p>
        Each actor heap is page-aligned and lives in memory—not in a cold pool or replay log. That means:
      </p>
      <ul>
        <li>No rehydration cost</li>
        <li>No idle instance burn</li>
        <li>No infrastructure gymnastics</li>
      </ul>
      <p>
        A single VM with 2 GB RAM can run up to <strong>20,000 live actors</strong> at full observability and still stay under budget.
      </p>
      <div class="diagram">
        1 actor = 104 KB
        20,000 actors = ~2 GB
        Cost = ~$10/month VM
        <br><br>
        <strong>That’s $0.0005 per actor per month.</strong>
      </div>
    </div>
  </div>
  
  <div class="slide">
    <div class="slide_section">The Pitch</div>
    <div class="title">Others Scale by Charging You More</div>
    <div class="content">
      <p>
        Platforms like Lambda@Edge, Fastly, and Durable Objects charge per invocation, per GB-s, per region.
      </p>
      <p>
        They are expensive because <strong>their model is expensive to run</strong>.
      </p>
      <div class="diagram">
        Lambda@Edge:
          ├─ $0.60 per 1M calls
          ├─ Cold starts
          └─ External DB for state
        
        DataVec:
          ├─ $0.005 per 1M invocations
          ├─ No cold starts
          └─ Live heap = live state
      </div>
    </div>
  </div>
  
  <div class="slide">
    <div class="slide_section">The Pitch</div>
    <div class="title">Profit-Positive Platform Economics</div>
    <div class="content">
      <p>
        DataVec doesn’t depend on usage fees to subsidize infrastructure. Its default mode of operation is margin-efficient:
      </p>
      <ul>
        <li>1 core = 300,000 invocations/sec</li>
        <li>1 GB RAM = 10,000+ live actors</li>
        <li>Persistence is just memory pages</li>
      </ul>
      <p>
        <strong>This is the first edge-native platform where structured compute is so efficient, it can be sold profitably at flat rates.</strong>
      </p>
    </div>
  </div>
  
  <div class="slide">
    <div class="slide_section">The Pitch</div>
    <div class="title">Visual Cost Stack: Others vs DataVec</div>
    <div class="content">
      <p>
        Serverless providers hide margin loss in a tower of services. DataVec collapses the stack into a single, efficient layer:
      </p>
      <div class="diagram">
        Traditional Stack:
          ├─ CDN Proxy
          ├─ Function Runtime
          ├─ Logging Pipeline
          ├─ State DB + Cache
          ├─ Observability Service
          └─ Retry & Orchestration Logic
  
        DataVec Stack:
          └─ Actor Runtime (in RAM)
             ├─ Heap = State
             ├─ Embedded Logging
             ├─ Built-in Observability
             └─ mmap() = Persistence
      </div>
      <p>
        <strong>We didn’t optimize the stack—we removed it.</strong>
      </p>
    </div>
  </div>
  
  <div class="slide">
    <div class="slide_section">The Pitch</div>
    <div class="title">Composable Locality: Isolation vs Cooperation</div>
    <div class="content">
      <p>
        DataVec actors scale across a full spectrum of execution models, from completely isolated functions to tightly bound cooperative drivers:
      </p>
      <div class="diagram">
        Actor Composition Spectrum:
          [Isolated Function]
            └─ Own heap
            └─ Memory masked via mprotect()
  
          [Micro-Process with Threads]
            └─ Shared heap
            └─ Cooperative coroutines
  
          [Multi-Process Cluster]
            └─ Ring buffer messaging (vk_socket)
            └─ Shared or isolated memory windows
  
          [Fused Driver Chain]
            └─ Fully cooperative, zero-copy logic flow
            └─ Execution passes without queues
      </div>
      <p>
        <strong>Developers control locality, isolation, and execution sharing—down to the page.</strong>
      </p>
    </div>
  </div>
  
  <div class="slide">
    <div class="slide_section">The End</div>
    <div class="title">Thank You</div>
    <div class="content">
      <p>
        This is the runtime for the next era—where structure is native, locality is the platform, and overhead is no longer a given.
      </p>
      <p>
        <strong>Let’s condense the cloud—and make it rain.</strong>
      </p>
  
      <p>To get in touch:</p>
      <ul>
        <li><strong>Email:</strong> <a href="mailto:founders@datavec.io" style="color:#66ffcc;">founders@datavec.io</a></li>
        <li><strong>Site:</strong> <a href="https://datavec.io" style="color:#66ffcc;">https://datavec.io</a></li>
        <li><strong>GitHub:</strong> <a href="https://github.com/alsosprachben/mnvkd" style="color:#66ffcc;">mnvkd on GitHub</a></li>
      </ul>  
    </div>
  </div>  
  
  <script>
    let currentSlide = 0;
    const slides = document.querySelectorAll('.slide');
    
    function showSlide(index) {
      slides.forEach((slide, i) => {
        slide.style.display = i === index ? 'block' : 'none';
      });
    }
  
    function changeSlide(direction) {
      currentSlide = (currentSlide + direction + slides.length) % slides.length;
      showSlide(currentSlide);
    }

    function goHome() {
      currentSlide = 0;
      showSlide(currentSlide);
    }
  
    // Initialize the first slide
    showSlide(currentSlide);
  </script>
  
</body>
</html>
